
<html>
<script type="text/javascript" src="MapBuilder.js"></script>
<script type="text/javascript" src="BuilderCalculations.js"></script>
<script type="text/javascript" src="BuilderVisuals.js"></script>
<script type="text/javascript" src="ShapeBuilder.js"></script>
<script type="text/javascript" src="MultimapMechanics.js"></script>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<link rel="stylesheet" type="text/css" href="MapBuilderStyles.css">

    <body>
	
		<table>
		<tr>
			<td colspan="2" class="layout">
				<div class="items" id="itemsArea"></div>
			</td>
		</tr>
		<tr>
			<td class="layout">
				<div id='GridGraphics'></div>
			</td>
			<td class="layout">
				<div id='lateralMenuGraphics'></div>
			</td>
		</tr>
		
		</table>
	

		<div id="statsGraphics"><div class='stats'><span id='topValue'></span><br><span>Item Type: </span><span id='itemType'>0</span><br><span>Rotation: </span><span id='rotation'>0</span><br><div ><span>Coordenate: </span><span id='positionX'>0</span> , <span id='positionY'>0</span></div></div></div>
		
    </body>
    <script>
		//Output elements
		var statistics;
        var itemType;
        var rotation;
        var positionX;
        var positionY;
        var topValue;
		
		//Graphic elements
        var table;
        var tableShapes;
        var lateralMenu;
		var shapeElements = [];
		
		//Colors
		const itemShowcaseColor = "#569CD6";
		const itemShadowColor = "#9CDCFE";
		const itemPlacedColor = "#569CD6";
		const clearedGridColor = "white";
		const itemSelectedColor = "#D69D85";
		const itemDefaultColor = "#1E1E1E";
		const mapCutColor = "#1E1E1E";
		
		//List Of Shapes
		var listOfShapes = [
			new Vector2Array([0],[0]),
			new Vector2Array([0,0],[0,1]),
			new Vector2Array([0,0,1],[0,1,1])
		];
		var listOfShapeNames = [
			"Box",
			"Wall",
			"Corner Wall"
		];
		var listOfShapeColors = [
			randomColor(),
			randomColor(),
			randomColor(),
		];
		
		//Keeps track on real time what's happening
		var currentItemPlacingInfo = new ItemPlacingInfo();


		//Everything starts here
        window.onload = function() {
			//Both share same stuff
			initializeMapEditorStatistics();
			initializeMapEditorShapes();
			initailizeKeyCombos();

			//Initialize Map editor
			initializeMapEditorGrid(20, 40);
			initializeMapEditorMenu();
			
			//Initialize Shapes editor
			initializeShapesEditorGrid(10, 10);
			initializeShapesEditorMenu();
			
			document.addEventListener('dragstart', (e) => {
			  e.preventDefault()
			})
			
			//Starts showing map editor while hidning shapes editor
			GoToMapEditor();
			//GoToShapesEditor();

			//FOR DEBUGGING ONLY
			//rows(3);
			//cols(3);
        }
		

		
		function initializeMapEditorGrid(x, y){
			//Creates grid
			let placingLcation = document.getElementById("GridGraphics");			
            table = generate_table(x, y);
			table.id = "grid";
			table.className = "gridMap";
			
			//Places grid 
			placingLcation.appendChild(table);
			
			//Initializes grid logic
			occupancyMap = Array(x).fill(null).map(()=>Array(y).fill(false));
			cutsMap = Array(x).fill(null).map(()=>Array(y).fill(false));
			
			//Add functionality to the grid
			var tablerowscount=table.getElementsByTagName("tbody")[0].getElementsByTagName("tr");
			for (let i=0; i<tablerowscount.length; i++) {
				//console.log(tablerowscount[i].cells);
				AddHoverListenerToElements(tablerowscount[i].cells);
			}
			
            AddClickListenerToElement(table, OnGridClick );
			AddListenerToScrollWheel(table);
			document.addEventListener('mouseup', function(e) { isClicking = false; });
		}
		
		function initializeMapEditorMenu(){
			//Creates HTML map editor's menu
			lateralMenu = document.getElementById("lateralMenuGraphics");
			lateralMenu.innerHTML = "<div class='control'><button class='sideButton downloadButton' onclick='DownloadMap()'><i class='material-icons'>download</i> Download</button><button class='sideButton' onclick='ResetMap()'><i class='material-icons'>delete</i> Reset Map</button></div>";
			
		}	
		
		function initializeMapEditorStatistics(){			
			//save references
			topValue = document.getElementById('topValue');
            itemType = document.getElementById('itemType');
            rotation = document.getElementById('rotation');
            positionX = document.getElementById('positionX');
            positionY = document.getElementById('positionY');
		}
		
		function initializeMapEditorShapes(shapeStartIndex=0){
			let itemsArea = document.getElementById('itemsArea');
			
			const fixedSizeOfShape = 6;
			const cellSize = 0.1;
			
			for(let i=0; i<listOfShapes.length; i++){
			
				//Skip nulled shapes
				if(listOfShapes[i] == null) continue;
			
				let maxValue = GetMaxValueOfCoordenates(listOfShapes[i]);
				let marginValue = maxValue + 3;
				let sizeFactor = fixedSizeOfShape / (cellSize*marginValue);
				//console.log("maxValue:"+maxValue+"; sizeFactor:"+sizeFactor);

				let item = generate_table(marginValue, marginValue, sizeFactor);
				//item.style.transform = "scale("+sizeFactor+")";
				
				let textNode = document.createTextNode(listOfShapeNames[i]);
				item.appendChild(textNode);
				item.className = "item";
				
				//Delete Icon
				let deleteIcon = document.createElement("i");
				textNode = document.createTextNode("delete");
				deleteIcon.className = "material-icons deleteIcon";
				deleteIcon.appendChild(textNode);
				item.appendChild(deleteIcon);
				deleteIcon.addEventListener('click', function(){ DeleteShape(i); } );
				
				//Add functionality to item shape
				itemsArea.appendChild( item );
				item.addEventListener('click', function(){ ChangeItem(i); } );
				
				let coordenates = GlobalizeCoordenates( listOfShapes[i] , 1, 1);
				printVisualsOfCoordenatesOnTable(coordenates, listOfShapeColors[i], item);
				
				shapeElements[i] = item;
			}
			
			let textElement = document.createElement("div");
			let textNode = document.createTextNode("+");
			textElement.classList.add('addShapeButton');
			textElement.appendChild(textNode);
			itemsArea.appendChild(textElement);
			textElement.addEventListener('click', function(){ GoToShapesEditor(); } );
			lastShapeElement = shapeElements[shapeStartIndex];
			ChangeItem(shapeStartIndex);
		}
		
		function initializeShapesEditorGrid(x, y){			
			//Creates grid
			let placingLcation = document.getElementById("GridGraphics");
            tableShapes = generate_table(x, y);
			tableShapes.id = "shapeMap";
			tableShapes.className = "shapeMap";
			
			//Creates the shape's name input
			let inputElement = document.createElement("input");
			let textNode = document.createTextNode("Name: ");
			inputElement.classList.add('inputName');
			inputElement.id = "inputName";
			inputElement.value = "Shape Name";
			inputElement.append(textNode);
			tableShapes.appendChild(inputElement);
			
			//Places grid 
			placingLcation.appendChild(tableShapes);
			
			//Initializes grid logic
			shapeMap = Array(x).fill(null).map(()=>Array(y).fill(false));
			
			//Add functionality to the grid
			var tablerowscount=tableShapes.getElementsByTagName("tbody")[0].getElementsByTagName("tr");
			for (let i=0; i<tablerowscount.length; i++) {
				//console.log(tablerowscount[i].cells);
				AddHoverListenerToElements(tablerowscount[i].cells);
			}
			AddClickListenerToElement(tableShapes, OnShapesGridClick);
		}
		
		function initializeShapesEditorMenu(){
			lateralMenu.innerHTML += "<div class='control'><button class='sideButton downloadButton' onclick='SaveShape()'><i class='material-icons'>save</i> Save</button><button class='sideButton' onclick='ReturnToMapEditor()'><i class='material-icons'>arrow_back_ios</i> Return</button><button class='sideButton' onclick='ResetShape()'><i class='material-icons'>delete</i> Reset Shape</button></div>";
		}
		

		

		
///////////////////// MAIN ////////////////////////////////////////////////////
		
		function ResetMap(){
			ResetOccupancyMap();
			ResetCutsMap();
		}

		function ResetOccupancyMap(){
			let formatedCoordenates = OccupancyMapToCoordenates(occupancyMap);
			printVisualsOfCoordenates(formatedCoordenates, clearedGridColor);
			
			historyOfPlacements = null;
			historyOfPlacements = [];
			historyIndex = 0;
			
			let mapLengthX = occupancyMap.length;
			let mapLengthY = occupancyMap[0].length;
			
			occupancyMap = Array(mapLengthX).fill(null).map(()=>Array(mapLengthY).fill(false));
			
			//Reset cuts in map. See MultimapMechanics.js for more info
		}

		function ResetCutsMap(){
			rows(nrows);
			cols(ncols);
		}
		
		function HideMapEditor(){
			table.style.display = "none";
			let lateralButtons = document.getElementsByClassName("control")[0];
			lateralButtons.style.display = "none";
		}
		
		
        function OnGridClickAndDrag(x, y){
			UpdateItemPlacingInfo(x, y);
			state = GetOccupancyOfPlacingInfo();

			if (state == FREE){
				PlaceCurrentItemInfo();
			}		
		}
		
        function OnGridClick(x, y){
			//OCCUPIED happens when you click directly over a shape in the map
			//OBSTRUCTED happens when you try to place a shape and indiretctly is being blocked by another
			//FREE is space availabe
			
			//Resets Ctrl+Z actions
			chainedUndoneIndex = 0;
			
			UpdateItemPlacingInfo(x, y);
			state = GetOccupancyOfPlacingInfo();
			
			if ( state == OUT_OF_BOUNDS){
				//console.log("OUT_OF_BOUNDS");
				return;
			}
			else if (state == OCCUPIED){
				//console.log("OCCUPIED");
				RemoveCurrentItemInfo();
			}
			else if (state == OBSTRUCTED){
				//console.log("OBSTRUCTED");
			}
			else if (state == MAP_CUT){
				//console.log("MAP_CUT");
			}
			else if (state == FREE){
				//console.log("FREE");
				PlaceCurrentItemInfo();
			}
        }
		
		function UpdateItemPlacingInfo(x, y){
			//Sooo. i know is confusing but here goes:
			// 1. Average volume of an object is its center position. Not the bounding box center
			// 2. Here changes the index-position for the center-volume-position of the object so it visualy rotates from its center
			// 3. The (rows, columns) system is different from the (x, y) system by 90 degrees or (-y, x)
			// 4. We need to register the index position as it was taken by a (x,y) system, so it changes again the index-position-row-col to index-position-xy
			// 5. Summary; internally we're using (row,col) as original detection of coordenates. Volume-center to place the visuals. And standar (x,y) as output

			//Creates an object {[x],[y]} where x and y are integrers
			let clickedCoordenate = new Vector2Array(x, y);
			currentItemPlacingInfo.positionX = x;
			currentItemPlacingInfo.positionY = y;
			
			//Finds info 
			let shape = listOfShapes[currentItemPlacingInfo.itemType];
			let shapeRotated = RotateCoordenatesByAngle(shape, currentItemPlacingInfo.rotation);
			
			//Reformat to volume average
			let averageVolume = AverageVolume(shapeRotated);
			let roundedAverageVolume = { x:Math.round(averageVolume.x), y:Math.round(averageVolume.y) };
			let volumeIndex = { x:(currentItemPlacingInfo.positionX-roundedAverageVolume.x), y:(currentItemPlacingInfo.positionY - roundedAverageVolume.y) };

			//make info
			let coordenates = GlobalizeCoordenates(shapeRotated, volumeIndex.x, volumeIndex.y);
			currentItemPlacingInfo.coordenates = coordenates;
		}
		
		function RemoveCurrentItemInfo(){
			let infoToRemove = FindHistoryInfoAtCurrentPlacement();
			DeleteFromHistoryOfPlacements(infoToRemove);
			printVisualsOfCoordenates(infoToRemove.coordenates, clearedGridColor);
			UpdateOccupancy(infoToRemove.coordenates, FREE);
			printHoverVisuals();
		}
		
		function PlaceCurrentItemInfo(){
			//Standar (x,y) system for ouputting
			let minValues = GetMinValuesOfCoordenates(currentItemPlacingInfo.coordenates)
			currentItemPlacingInfo.positionX = minValues.x;
			currentItemPlacingInfo.positionY = minValues.y;
			
			printVisualsOfCoordenates(currentItemPlacingInfo.coordenates, listOfShapeColors[currentItemPlacingInfo.itemType]);
			UpdateOccupancy(currentItemPlacingInfo.coordenates, OCCUPIED);
			RegisterHistoryOfPlacements(currentItemPlacingInfo);
		
		}

		var lastShapeElement;
		function ChangeItem(itemIndex){
			
			if(itemIndex > listOfShapes.length-1)
				itemIndex = listOfShapes.length-1;
		
			currentItemPlacingInfo.itemType = itemIndex;
			itemType.innerHTML = currentItemPlacingInfo.itemType;
			
			lastShapeElement.style.backgroundColor = itemDefaultColor;
			shapeElements[itemIndex].style.backgroundColor = itemSelectedColor;
			lastShapeElement = shapeElements[itemIndex];
		
			//console.log("Item changed to type: " + itemIndex);
		}
	    
		
		function DownloadMap(){
		
			//let outputData = JSON.stringify( formatCoordenates() );
			let outputData = FormatOutput();
			let ouputShapes = formatShapes();
			
			//console.log("DOWNLOADED:");
			//console.log(outputData);
            download("WebBuilderMap"+ ".json", outputData + "$" + ouputShapes);
        }
/////////////////////////////////////////////////////////////////////////



    </script>
</html>